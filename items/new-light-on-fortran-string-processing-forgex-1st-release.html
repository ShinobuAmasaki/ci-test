<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="utf-8" />
   <meta name="viewport" content="width=device-width,initial-scale=1" />
   <meta name="twitter:card" content="summary" />
        <meta name="description" content="An article about Fortran
Reguler Expression (Forgex)." />
   <meta name="twitter:description" content="An article about Fortran
Reguler Expression (Forgex)." />
   <meta name="og:description" content="An article about Fortran Reguler
Expression (Forgex)." />
      <meta property="og:title" content="Forgex 1st Release" /> 
      <meta name="twitter:site" content="@amasaki203" />
   <meta name="twitter:image" content="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/img/shinobu.png?raw=true" />
   <meta property="og:type" content="website" />
   <meta property="og:url" content="https://shinobuamasaki.github.io/new-light-on-fortran-string-processing-forgex-1st-release.html" />
   <meta property="og:site_name" content="Amasaki Shinobu's website" />
   <meta property="og:image" itemprop="image" content="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/img/shinobu.png?raw=true">

   <title>Forgex 1st Release | Amasaki Shinobu's Website</title>
	
   <link rel="icon" href="https://raw.githubusercontent.com/ShinobuAmasaki/ShinobuAmasaki.github.io/main/favicon.ico" type="image/x-icon" >
   
   <link rel="stylesheet" type="text/css" href="../style/common.css">
   <link rel="stylesheet" type="text/css" href="https://shinobuamasaki.github.io/style/highlight.css">
   <link href="https://use.fontawesome.com/releases/v6.2.0/css/all.css" rel="stylesheet">
   <link rel="stylesheet" type="text/css" href="../style/header.css">
   <script src="https://shinobuamasaki.github.io/style/highlight.min.js"></script>
   <script>hljs.highlightAll();</script>
   <link rel="stylesheet" type="text/css" href="../style/none-highlight.css">
</head>
<body>
   <header>
      <div class="inner">
         <a href="https://shinobuamasaki.github.io/"><img id="myicon" src="../img/shinobu.png" width="80px" height="80px" border="solid 10px #000"></a>
         <p class="logo">Amasaki Shinobu's Website</p>
         <ul class="header-buttons">
            <li><a href="https://shinobuamasaki.github.io/">TOP</a></li>
         </ul>
      </div>
   </header>
<main>
   <div class="container">
      <div class="child">
         <h1
         id="new-light-on-fortran-string-processing-forgex-1st-release">New
         Light on Fortran String Processing: Forgex 1st Release</h1>
         <p>Author: Amasaki Shinobu (雨崎しのぶ)</p>
         <p>Twitter: <a href="https://twitter.com/amasaki203"><span
         class="citation"
         data-cites="amasaki203">@amasaki203</span></a></p>
         <p>Posted on: 2023-12-25 JST Updated on: 2023-12-27 JST</p>
         <h2 id="abstract">Abstract</h2>
         <p><a href="https://github.com/ShinobuAmasaki/forgex">I’ve
         developed a new project called ‘Forgex’, an abbreviation for
         ‘Fortran Regular Expression’, and its first release took place
         on December 24th.</a></p>
         <p>Forgex is a regular expression engine written entirely in
         Fortran. It is a library module that is executable with just a
         Fortran compiler, devoid of dependencies other than a compiler
         and Fortran Package Manager (FPM). This library is freely
         available under the MIT license.</p>
         <h2 id="about-forgex">About Forgex</h2>
         <p>Forgex is a library module designed for processing regular
         expressions (pronounced as ‘forge x’ by me).</p>
         <p>The distinctive features implemented in this library
         include:</p>
         <ul>
         <li>UTF-8 code set support</li>
         <li>Operator-oriented API</li>
         <li>FPM and CMake support</li>
         </ul>
         <h3 id="regular-expression-processing-implemented">Regular
         Expression Processing Implemented</h3>
         <p>This section lists the regular expression patterns that are
         implemented in Forgex.</p>
         <h4 id="metacharacters">Metacharacters</h4>
         <ul>
         <li><code>|</code>: Alternation</li>
         <li><code>*</code>: Match zero or more</li>
         <li><code>+</code>: Match one or more</li>
         <li><code>?</code>: Match zero or one</li>
         <li><code>\</code>: Escape a metacharacter</li>
         <li><code>.</code>: Match any character</li>
         </ul>
         <h4 id="character-classes">Character Classes</h4>
         <ul>
         <li><code>[a-z]</code>: Character classes</li>
         <li><code>[^a-z]</code>: Inverted character classes</li>
         </ul>
         <p>Both character classes and their invertion support UTF-8
         character sets, e. g. <code>[α-ωぁ-ん]</code></p>
         <h4 id="anchor">Anchor</h4>
         <ul>
         <li><code>^</code>: Match at the beginning of the line</li>
         <li><code>$</code>: Match at the end of the line</li>
         </ul>
         <h4 id="repetition">Repetition</h4>
         <ul>
         <li><code>{2}</code>: number of repetitions</li>
         <li><code>{,3}</code>: maximum number of repetitions</li>
         <li><code>{5,}</code>: minimum number of repetitions</li>
         <li><code>{7, 11}</code>: both minimum and maximum numbers of
         repetitions</li>
         </ul>
         <h4 id="shorthand-with-backslash">Shorthand with Backslash</h4>
         <ul>
         <li><code>\t</code>: TAB</li>
         <li><code>\n</code>: Line Feed (LF) or Carriage return (CR) and
         LF</li>
         <li><code>\r</code>: CR</li>
         <li><code>\s</code>: A blank character (white space, TAB, LF,
         CR, Form Feed, Idepgraphic Space U+3000)</li>
         <li><code>\S</code>: Other than <code>\s</code></li>
         <li><code>\w</code>: <code>[a-zA-Z0-9_]</code></li>
         <li><code>\W</code>: Other than <code>\w</code></li>
         <li><code>\d</code>: <code>[0-9]</code></li>
         <li><code>\D</code>: Other than<code>\d</code>（therefore
         <code>[^0-9]</code>）</li>
         </ul>
         <h2 id="usage">Usage</h2>
         <h3 id="build">Build</h3>
         <p>Operation has been confirmed with the following
         compilers:</p>
         <ul>
         <li>GNU Fortran (<code>gfortran</code>) v13.2.1</li>
         <li>Intel Fortran Compiler (<code>ifx</code>) 2024.0.0
         20231017</li>
         </ul>
         <p>To build this, the use of FPM is assumed. An alternative
         option is CMake.</p>
         <h4 id="building-with-fpm">Building with FPM</h4>
         <p>Add the following to your project’s
         <code>fpm.toml</code>:</p>
         <pre class="toml"><code>[dependencies]
forgex = {git = &quot;https://github.com/shinobuamasaki/forgex&quot;}</code></pre>
         <h4 id="alternative-building-with-cmake">(Alternative) Building
         with CMake</h4>
         <p>Forgex also supports building with CMake.</p>
         <pre class="shell"><code># download forgex 
wget https://github.com/ShinobuAmasaki/forgex/archive/refs/tags/v1.0.tar.gz

# decompress
tar xvzf ./v1.0.tar.gz

# change directory
cd ./forgex-1.0

# make &#39;build&#39; directory 
cmake -S . -B ./build

# build
cmake --build ./build

# install
sudo cmake --install ./build --prefix /usr/local

# test
cd ./build
ctest</code></pre>
         <p>While it is possible to build using CMake, I recommend the
         more straightforward approach using FPM.</p>
         <h3 id="apis">APIs</h3>
         <p>Declaring <code>use forgex</code> at the top of your program
         introduces the <code>.in.</code> and <code>.match.</code>
         operators and the <code>regex</code> function. Below we will
         look at how to use each of these three.</p>
         <h4 id="the-.in.-operator">The <code>.in.</code> operator</h4>
         <p>The <code>.in.</code> operator returns true if the pattern
         (left operand) is contained in the string (right operand).</p>
         <pre class="fortran"><code>block
   character(:), allocatable :: pattern, str

   pattern = &#39;foo(bar|baz)&#39;
   str = &quot;foobarbaz&quot;
   print *, pattern .in. str  ! T

   str = &quot;foofoo&quot;
   print *, pattern .in. str  ! F
end block</code></pre>
         <h4 id="the-.match.-operator">The <code>.match.</code>
         operator</h4>
         <p>The <code>.match.</code> operator returns true if the
         pattern and the string match exactly.</p>
         <pre class="fortran"><code>block
   character(:), allocatable :: pattern, str

   pattern = &#39;\d{3}-\d{4}&#39;
   str = &#39;100-0001&#39;
   print *, pattern .match. str  ! T

   str = &#39;1234567&#39;
   print *, pattern .match. str  ! F
end block</code></pre>
         <h4 id="the-regex-function">The <code>regex</code>
         function</h4>
         <p>The <code>regex</code> function takes a pattern and string
         as arguments and returns the matched substring. The substring
         is the leftmost and longmost match in the string.</p>
         <pre class="fortran"><code>block
   character(:), allocatable :: pattern, str
   
   pattern = &#39;[a-z]{3}&#39;
   str = &#39;foobarbaz&#39;

   print *, regex(pattern, str)  ! foo
end block</code></pre>
         <p>As an option, you can also pass an integer-type arugment
         <code>length</code> that will stores the byte length of the
         substring.</p>
         <pre class="fortran"><code>block
   character(:), allocatable :: pattern, str
   integer :: length
   
   pattern = &#39;[a-z]{3}&#39;
   str = &#39;foobarbaz&#39;

   print *, regex(pattern, str, length)  ! foo
   print *, length               ! 3
end block</code></pre>
         <p>The interface of the <code>regex</code> function is as
         follows:</p>
         <pre class="fortran"><code>function regex (pattern, str, length) result(res)
   character(*), intent(in) :: pattern, str
   integer, intent(inout), optional :: length
   character(:), allocatable :: res</code></pre>
         <h3 id="utf-8-string-processing">UTF-8 String Processing</h3>
         <p>UTF-8 string can be matched using regular expression
         patterns just like ASCII strings. The following example
         demonstrates matching Chinese characters. In this example, the
         variable <code>length</code> stores the byte length, and in
         this case there 10 3-byte characters, so the length is 30.</p>
         <pre class="fortran"><code>block
   character(:), allocatable :: pattern, str
   integer :: length
   
   pattern = &quot;夢.{3,7}胡蝶&quot;
   str = &quot;昔者莊周夢爲胡蝶　栩栩然胡蝶也&quot;
   
   print *, pattern .in. str            ! T
   print *, regex(pattern, str, length) ! 夢爲胡蝶　栩栩然胡蝶
   print *, length                      ! 30 (is 3-byte * 10 characters)
   
end block</code></pre>
         <h2 id="internal-implementation">Internal Implementation</h2>
         <p>In the implementation of regular expression engines, there
         are broadly two approaches: using Deterministic Finite
         Automaton (DFA) and constructing a virtual machine. In Forgex,
         I have adopted the former approach based on DFA.</p>
         <p>Due to this choice, the following features will NOT be
         implemented:</p>
         <ul>
         <li>Backreference</li>
         <li>Recursive patterns</li>
         </ul>
         <p>Additionally, at the current stage, an on-the-fly DFA
         construction algorithm has not been implemented, thereby
         failing to address the issue of state number explosion.
         Consequently, patterns like <code>[a-z]{20}b</code> fall into
         the category of challenging cases.</p>
         <h2 id="conclusion">Conclusion</h2>
         <p>While challenges such as addressing state explosion,
         optimization, and incorporating parallel processing remain, I
         have opted for the current release as the essential features
         are now in place.</p>
         <p>With the release of this library, I hope for an improvement
         in the convenience of your Fortran string processing.</p>
         <h2 id="acknowlegements">Acknowlegements</h2>
         <p>For the algorithm of the power set construction method and
         syntax analysis, I referred to Russ Cox’s article and Kondo
         Yoshiyuki’s book.</p>
         <p>The implementation of the priority queue was based on <a
         href="https://github.com/ue1221/fortran-utilities">the code
         written by ue1221</a>.</p>
         <p>The idea of applying the .in. operator to strings was
         inspired by kazulagi’s one.</p>
         <h2 id="references">References</h2>
         <ol type="1">
         <li>Russ Cox <a
         href="https://swtch.com/~rsc/regexp/regexp1.html">“Regular
         Expression Matching Can Be Simple And Fast”</a>, 2007</li>
         <li>近藤嘉雪 (Kondo Yoshiyuki), “定本
         Cプログラマのためのアルゴリズムとデータ構造”, 1998, SB
         Creative.</li>
         <li><a
         href="https://github.com/ue1221/fortran-utilities">ue1221/fortran-utilities</a></li>
         <li>Haruka Tomobe (kazulagi), <a
         href="https://github.com/kazulagi">https://github.com/kazulagi</a>,
         <a
         href="https://qiita.com/soybean/items/7cdd2156a9d8843c0d91">his
         article in Japanese</a></li>
         </ol>
      </div>
   </div>
</main>
</body>
</html>
