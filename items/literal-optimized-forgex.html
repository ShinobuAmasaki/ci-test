<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="utf-8" />
   <meta name="viewport" content="width=device-width,initial-scale=1" />
   <meta name="twitter:card" content="summary" />
        <meta name="description" content="Fortran Regular Expression
version 3.4 have been released." />
   <meta name="twitter:description" content="Fortran Regular Expression
version 3.4 have been released." />
   <meta name="og:description" content="Fortran Regular Expression
version 3.4 have been released." />
      <meta property="og:title" content="Forgex v3.4 Released" /> 
      <meta name="twitter:site" content="@amasaki203" />
   <meta name="twitter:image" content="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/img/shinobu.png?raw=true" />
   <meta property="og:type" content="website" />
   <meta property="og:url" content="https://shinobuamasaki.github.io/literal-optimized-forgex.html" />
   <meta property="og:site_name" content="Amasaki Shinobu's website" />
   <meta property="og:image" itemprop="image" content="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/img/shinobu.png?raw=true">

   <title>Forgex v3.4 Released | Amasaki Shinobu's Website</title>
	
   <link rel="icon" href="https://raw.githubusercontent.com/ShinobuAmasaki/ShinobuAmasaki.github.io/main/favicon.ico" type="image/x-icon" >
   
   <link rel="stylesheet" type="text/css" href="../style/common.css">
   <link rel="stylesheet" type="text/css" href="https://shinobuamasaki.github.io/style/highlight.css">
   <link href="https://use.fontawesome.com/releases/v6.2.0/css/all.css" rel="stylesheet">
   <link rel="stylesheet" type="text/css" href="../style/header.css">
   <script src="https://shinobuamasaki.github.io/style/highlight.min.js"></script>
   <script>hljs.highlightAll();</script>
   <link rel="stylesheet" type="text/css" href="../style/none-highlight.css">
</head>
<body>
   <header>
      <div class="inner">
         <a href="https://shinobuamasaki.github.io/"><img id="myicon" src="../img/shinobu.png" width="80px" height="80px" border="solid 10px #000"></a>
         <p class="logo">Amasaki Shinobu's Website</p>
         <ul class="header-buttons">
            <li><a href="https://shinobuamasaki.github.io/">TOP</a></li>
         </ul>
      </div>
   </header>
<main>
   <div class="container">
      <div class="child">
         <h1 id="forgex-v3.4-literal-search-optimizations">Forgex v3.4:
         Literal Search Optimizations</h1>
         <p>Author: Amasaki Shinobu（雨崎しのぶ）</p>
         <p>Twitter: <a href="https://x.com/amasaki203"><span
         class="citation"
         data-cites="amasaki203">@amasaki203</span></a></p>
         <p>Posted on: 2024-08-25 JST</p>
         <h2 id="abstract">Abstract</h2>
         <p><a
         href="https://github.com/ShinobuAmasaki/forgex/releases/tag/v3.4">Forgex—Fortran
         Regular Expression—version 3.4</a> with literal search
         optimizations and a CLI tool is available.</p>
         <h2 id="details">Details</h2>
         <p>Referring to <a href="./dream-of-pure-regex.html">my
         previous article</a>, here is an introduction to the features
         of the version 3.4 of Forgex.</p>
         <h3 id="api-changes">API changes</h3>
         <p>The <code>.in.</code> and <code>.match.</code> operators
         remain functional, and have been extended to work on arrays.
         From v3.0, the <code>regex</code> procedure has been changed
         from a function to a subroutine. If you want to get a string as
         the return value, use the <code>regex_f</code> function. For
         detailed usage information, <a
         href="https://github.com/ShinobuAmasaki/forgex">see the README
         in the repository</a>.</p>
         <h3 id="operators-with-pure-elemental-attribute">Operators with
         Pure Elemental attribute</h3>
         <p>A dream that I discussed in the previous article—to provide
         <code>pure</code> API procedures—has come true in v3.0. From
         v3.0 onward, Forgex provides API operators with
         <code>pure elemental</code> attributes, and users can use them
         on array operations and in <code>do concurrent</code> blocks
         and OpenMP parallel blocks. While I could have parallelized the
         internal processing of Forgex to achieve faster text
         processing, I chose instead to provide a robust, easy-to-use
         API that, although not particularly fast, is primarily aimed at
         assisting with numerical calculations which is the main
         interest of Fortran users.</p>
         <p>Below is an example of using the <code>.in.</code> operator
         in an array operation:</p>
         <pre class="fortran"><code>block
   integer, parameter :: siz = 5
   character(:), allocatable :: pattern
   character(8) :: text_array(siz)
   logical :: result_array(siz)
   
   pattern = &quot;(^a)|(.*a\s*$)&quot;
   ! This pattern matches character a at the beginning or the trailing.

   text_array = [&quot;alpha   &quot;, &quot;bravo   &quot;, &quot;charlie &quot;, &quot;delta   &quot;, &quot;echo    &quot;]
   result_array(1:siz) = pattern .in. text_array(1:siz)
   
   print *, result_array    ! T F F T F
end block</code></pre>
         <p>The internal implementation of Forgex uses one-dimensional
         arrays of derived types to represent an abstract syntax tree
         (AST), non-deterministic finite automaton (NFA), and
         deterministic finite automaton (DFA). Child nodes of AST, as
         well as states and transitional destinations of NFA and DFA,
         are managed as indices of arrays. This approach helps Forgex
         achieve fast processing because arrays in Fortran are fast and
         feature-rich, unlike graph implementations using pointers.
         However, this comes at the expense of some memory
         efficiency.</p>
         <p>The previous pointer-based implementation has been revamped,
         and most of the source code has been replaced with new code.
         During this process, the principles of object-oriented
         programming are introduced. Each node in the tree and automata
         is defined as a derived type, and to represent AST, NFA, and
         DFA, further derived types are defined containing arrays of
         these types. Using type-bound procedures reduces the number of
         arguments needed when calling procedures, resulting in more
         concise code description. Additionally, this implementation
         helps avoid using global variables, which cannot be utilized in
         procedures with the <code>pure</code> attribute, by
         substituting component variables of derived types.</p>
         <p>Note: the v1.4 feature of remembering the DFA of previous
         patterns has been removed, as it was incompatible with the
         <code>pure</code> attribute of operators.</p>
         <h3 id="literal-search-optimization">Literal Search
         Optimization</h3>
         <p>The previous article also discussed literal search
         optimization as a next step in this project. This feature has
         been implemented in the v3.3, and it performs more efficiently
         than brute-force matching for certain regex patterns and input
         text strings. For instance, consider checking whether the regex
         pattern <code>ab[^x]d</code> is contained in the input text
         <code>cdefghabcde</code>. This matches <code>abcd</code> from
         the 7th to 10th characters. In previous versions, the algorithm
         was naive and inefficient, trying to match from the 1st
         character and, if that failed, moving on to the 2nd character,
         and so on. Literal search optimization first extracts the
         prefix <code>ab</code> and the suffix <code>d</code> from the
         AST of the regex pattern, then uses the <code>index</code>
         intrinsic function to locate the prefix. The <code>index</code>
         function is much faster than the regex engine, so it skips the
         first 6 characters, <code>cdefgh</code>, which do not need to
         be checked, and starts the engine directly from the 7th
         character. This reduces unnecessary comparisons and enables
         more efficient processing.</p>
         <p>Currently, one prefix and one suffix are extracted as
         literal strings, excluding character classes and closures. For
         alternations, the intersection of the literal is extracted.
         Literal extraction can be extended to small character classes,
         but this involves a trade-off between the overhead of
         extraction and the additional time spent on searching, on the
         one hand, and time saved by skipping, on the other hand.
         Therefore, I’m currently wondering if this should be
         implemented.</p>
         <h3 id="command-line-tool">Command-line Tool</h3>
         <p>Although not mentioned in the previous article, since v3.1
         the development process has required additional tools. Starting
         with v3.2 a command line tool was introduced that can be used
         to test and benchmark Forgex. This application uses both
         Forgex’s internal modules and APIs to provide step-by-step
         information on how the AST, NFA and DFA are generated from the
         pattern, along with approximate execution time and memory
         consumption.</p>
         <p>For example, to perform the matching discussed in the
         previous section, run the following command:</p>
         <pre class="shell"><code>forgex-cli find match lazy-dfa &quot;ab[^x]d&quot; .in. &quot;cdefghabcde&quot;</code></pre>
         <p>Or if you execute it from <code>fpm run</code>, run the
         following command:</p>
         <pre class="shell"><code>fpm run forgex-cli --profile release -- find match lazy-dfa &quot;ab[^x]d&quot; .in. &quot;cdefghabcde&quot;</code></pre>
         <p>These will give you the following output:</p>
         <div class="none-highlight-user">
         <pre><code>             pattern: ab[^x]d
                text: &#39;cdefghabcde&#39;
          parse time:        61.8μs
extract literal time:        28.2μs
         runs engine:         T
    compile nfa time:        18.7μs
 dfa initialize time:         1.6μs
         search time:       191.3μs
     matching result:         T
  memory (estimated):      5943

========== Thompson NFA ===========
state    1: (a, 5)
state    2: &lt;Accepted&gt;
state    3: (d, 2)
state    4: ([&lt;SPACE&gt;-&quot;`&quot;], 3)(a, 3)(b, 3)(c, 3)(d, 3)([&quot;e&quot;-&quot;w&quot;], 3)([&quot;y&quot;-&lt;U+1FFFFF&gt;], 3)
state    5: (b, 4)
=============== DFA ===============
   1 : a=&gt;2
   2 : b=&gt;3
   3 : c=&gt;4
   4 : d=&gt;5
   5A:
state    1  = ( 1 )
state    2  = ( 5 )
state    3  = ( 4 )
state    4  = ( 3 )
state    5A = ( 2 )
===================================</code></pre>
         </div>
         <p>If you want to get information about the AST, run the
         following command:</p>
         <pre class="shell"><code>forgex-cli debug ast  &quot;ab[^x]d&quot;    </code></pre>
         <p>And then, you will get output similar to the following.</p>
         <div class="none-highlight-user">
         <pre><code>        parse time:        51.1μs 
      extract time:        19.7μs
 extracted literal:
  extracted prefix: ab
  extracted suffix: d
memory (estimated):       827
(concatenate (concatenate (concatenate &quot;a&quot; &quot;b&quot;) [ &quot; &quot;-&quot;w&quot;; &quot;y&quot;-&quot;&lt;U+1FFFFF&gt;;]) &quot;d&quot;)</code></pre>
         </div>
         <p>From the result, we can see that in this example,
         <code>ab</code> is extracted as the prefix and <code>d</code>
         is extracted as the suffix. <a
         href="https://shinobuamasaki.github.io/forgex/page/English/forgex_on_command_line_en.html">See
         the documentation for more information on how to use this
         command.</a></p>
         <h3 id="bugfix">Bugfix</h3>
         <p>Versions prior to v3.3 did not handle position matching
         carets and dollars very well. I fixed the handling of these by
         improving the <code>forgex_api_internal_m</code> module. This
         fix allows the caret and dollar signs to be matched correctly
         even when they are surrounded by parentheses, such as in the
         example above: <code>(^a)|(.*a\s*$)</code>. The relevant test
         cases have been added in
         <code>test/test_api/test_case_007.f90</code>.</p>
         <h3 id="to-do">To Do</h3>
         <p>I aim to add features in the future for the following:</p>
         <ul>
         <li>Implement advanced Unicode features.</li>
         <li>Handle invalid characters in UTF-8.</li>
         </ul>
         <h2 id="conclusion">Conclusion</h2>
         <p>This article covered new features, the <code>pure</code>
         attribute, a command line tool, optimization and a bug fix
         since Forgex version 3. With this upgrade, Forgex has made
         minimal changes to the API and significant changes to the
         internal implementation to add functionality and improve
         processing speed, and also provided tools to verify this. Not
         much is decided about the future of this project, but in the
         short term I will be focusing on improving the documentation
         and adding test cases.</p>
         <h2 id="acknowledgements">Acknowledgements</h2>
         <p>The command line interface design for this application was
         inspired by <a
         href="https://github.com/rust-lang/regex/tree/master/regex-cli">the
         Rust language’s <code>regex-cli</code></a>.</p>
         <h2 id="references">References</h2>
         <ol type="1">
         <li><a href="./dream-of-pure-regex.html">Dream of PURE Regex -
         Amasaki Shinobu</a>, Jul. 2024</li>
         <li><a
         href="https://github.com/rust-lang/regex/tree/master/regex-cli">rust-lang/regex/regex-cli</a></li>
         </ol>
      </div>
   </div>
</main>
</body>
</html>
