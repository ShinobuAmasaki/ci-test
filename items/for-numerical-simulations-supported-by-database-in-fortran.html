<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="utf-8" />
   <meta name="viewport" content="width=device-width,initial-scale=1" />
   <meta name="twitter:card" content="summary" />
        <meta property="og:title" content="For Numerical Simulations
Supported by Database in Fortran" /> 
      <meta name="twitter:site" content="@amasaki203" />
   <meta name="twitter:image" content="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/img/shinobu.png?raw=true" />
   <meta property="og:type" content="website" />
   <meta property="og:url" content="https://shinobuamasaki.github.io/for-numerical-simulations-supported-by-database-in-fortran.html" />
   <meta property="og:site_name" content="Amasaki Shinobu's website" />
   <meta property="og:image" itemprop="image" content="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/img/shinobu.png?raw=true">

   <title>For Numerical Simulations Supported by Database in
Fortran | Amasaki Shinobu's Website</title>
	
      <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha256-tkzDFSl16wERzhCWg0ge2tON2+D6Qe9iEaJqM4ZGd4E=" crossorigin="anonymous" type="text/css" rel="stylesheet">
   <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha256-gNVpJCw01Tg4rruvtWJp9vS0rRchXP2YF+U+b2lp8Po=" crossorigin="anonymous" type="text/javascript"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha256-ExtbCSBuYA7kq1Pz362ibde9nnsHYPt6JxuxYeZbU+c=" crossorigin="anonymous" type="text/javascript"></script>
   
   <link rel="icon" href="https://raw.githubusercontent.com/ShinobuAmasaki/ShinobuAmasaki.github.io/main/favicon.ico" type="image/x-icon" >
   
   <link rel="stylesheet" type="text/css" href="../style/common.css">
   <link rel="stylesheet" type="text/css" href="https://shinobuamasaki.github.io/style/highlight.css">
   <link href="https://use.fontawesome.com/releases/v6.2.0/css/all.css" rel="stylesheet">
   <link rel="stylesheet" type="text/css" href="../style/header.css">
   <script src="https://shinobuamasaki.github.io/style/highlight.min.js"></script>
   <script>hljs.highlightAll();</script>
   <link rel="stylesheet" type="text/css" href="../style/none-highlight.css">
</head>
<body>
   <header>
      <div class="inner">
         <a href="https://shinobuamasaki.github.io/"><img id="myicon" src="../img/shinobu.png" width="80px" height="80px" border="solid 10px #000"></a>
         <p class="logo">Amasaki Shinobu's Website</p>
         <ul class="header-buttons">
            <li><a href="https://shinobuamasaki.github.io/">TOP</a></li>
         </ul>
      </div>
   </header>
<main>
   <div class="container">
      <div class="child">
         <h1
         id="for-numerical-simulations-supported-by-database-in-fortran">For
         Numerical Simulations Supported by Database in Fortran</h1>
         <p>Author: Amasaki Shinobu (雨崎しのぶ)</p>
         <p>Posted on: 2023-12-02 JST</p>
         <h2 id="abstract">Abstract</h2>
         <p>I previously have posted an article titled <a
         href="./accessing-a-database-server-via-fortran-en.html">‘Accessing
         a Database Server via Fortran.’</a> In this article, I would
         like to continue from that point, and illustrate how to manage
         data in a numerical computing program using Libpq-Fortran and
         PostgreSQL.</p>
         <h2 id="contents">Contents</h2>
         <ul>
         <li><a href="#introduction">Introduction</a></li>
         <li><a href="#example-problem-1-d-advection-equation">Example
         Problem: 1-D Advection Equation</a></li>
         <li><a href="#preparation">Preparation</a></li>
         <li><a href="#execute-simulations">Execute Simulations</a>
         <ul>
         <li><a href="#main_loop"><code>main_loop</code></a></li>
         <li><a href="#data_output"><code>data_output</code></a></li>
         <li><a
         href="#data_registration"><code>data_registration</code></a></li>
         <li><a href="#execute-main-program">Execute Main
         Program</a></li>
         <li><a href="#check-the-registered-data">Check the Registered
         Data</a></li>
         </ul></li>
         <li><a href="#retrieve-the-data-for-plot">Retrieve the Data for
         Plot</a></li>
         <li><a href="#conclusion">Conclusion</a></li>
         </ul>
         <h2 id="introduction">Introduction</h2>
         <p>The primary goal for many Fortran programmers is likely to
         write numerical computing programs and evaluate thier results.
         Here, the process of numerical simulation can be classified as
         follows:</p>
         <ol type="1">
         <li>Write the source code on source files.</li>
         <li>Execute the simulation by providing input files and obtain
         output files.</li>
         <li>Visualize the results using a plotting script and obtain
         image files.</li>
         <li><code>goto</code> 1 (Repeat the process by returning to
         step 1).</li>
         </ol>
         <p>When it comes to managing these files, it is generally
         evident that utilizing a version control system (e. g. Git,
         SVN) is the best approach for handling source code and scripts
         that are constantly changing. On the other hand, determining
         the most effective method for managing input and output files
         in Step 2 is not as straightforward.</p>
         <p>If opting for file system management, one might attempt the
         following naming and directory structuring:</p>
         <ul>
         <li>Assign unique names by adding timestamps or keywords to the
         file names, such as
         <code>foobar_20231210_123456_baz.dat</code>.</li>
         <li>Use directories for categorization, for instance,
         <code>result/foo-scheme/bar-simulation/baz_20231210.dat</code></li>
         </ul>
         <p>These methods can encounter issues such as name collisions
         when parallel processing, longer directory paths leading to
         increased complexity in extracting data, and the inconvinience
         of devising lengthly unique names. Dealing with these problems,
         while manageable manually for a small amount of data, may
         become impractical as the data volume increases
         substantially.</p>
         <p>In this article, we will discuss practical methods for
         managing the continuously increasing data from numerical
         simulaitons using PostgreSQL—a relational database management
         system— and Libpq-Fortran—its Fortran frontend.</p>
         <h2 id="example-problem-1-d-advection-equation">Example
         Problem: 1-D Advection Equation</h2>
         <p>Taking the numerical simulation of the one-dimensional
         advection equation as an example, we vary parameters, execute
         simulaitons, and register the results in a database.</p>
         <p>The one-dimensional advection equation is given by:</p>
         <p>​ <span class="math display">\[\frac{\partial u}{\partial t}
         + \frac{\partial f}{\partial x} = 0, f= cu.\]</span></p>
         <p>Discretizing this equation using the explicit Eular method,
         Lax-Friedrich scheme and Lax-Wendroff scheme, we obtain the
         following difference equations:</p>
         <p>​ Explicit Eular method:</p>
         <p>​ <span class="math display">\[ u^{n+1}_{j} = u^{n}_{j} -
         \frac{\Delta t}{\Delta x} ( \tilde
         f^{n+\frac{1}{2}}_{j+\frac{1}{2}} -  \tilde
         f^{n-\frac{1}{2}}_{j-\frac{1}{2}}),\]</span></p>
         <p>​ Lax-Friedrich scheme:</p>
         <p>​ <span class="math display">\[\tilde f
         ^{n+\frac{1}{2}}_{j+\frac{1}{2}} = \frac{1}{2}[(f^n_{j+1} +
         f^n_j) - \frac{\Delta x}{\Delta t}(u^n_{j+1} -
         u^n_j)],\]</span></p>
         <p>​ Lax-Wendroff scheme:</p>
         <p>​ <span class="math display">\[\tilde f
         ^{n+\frac{1}{2}}_{j+\frac{1}{2}} = \frac{1}{2}[(1 -
         c\frac{\Delta t}{\Delta x})f^n_{j+1}+ (1+ c\frac{\Delta
         t}{\Delta x})f^n_j], \]</span></p>
         <p>where <span class="math inline">\(\tilde f\)</span> is the
         numerical flux, <span class="math inline">\(f^n_{j} = f(u^n_j)
         = cu^n_j\)</span>, <span class="math inline">\(c\)</span>
         represents the characteristic speed, <span
         class="math inline">\(\Delta t\)</span> is the time step size,
         and <span class="math inline">\(\Delta x\)</span> is the
         spatial grid spacing.</p>
         <p>The three quantities, <span
         class="math inline">\(c\)</span>, <span
         class="math inline">\(\Delta t\)</span>, and <span
         class="math inline">\(\Delta x\)</span>, characterize a
         simulation of this equation, serving as parameters that defines
         a single simulation.</p>
         <h2 id="preparation">Preparation</h2>
         <h3 id="create-user-and-database">Create User and Database</h3>
         <p>In the following Fortran program, it connect to a PostgreSQL
         server on the localhost and executes two commands.</p>
         <pre class="fortran"><code>program create_database
   use, intrinsic :: iso_c_binding
   use :: libpq
   implicit none
   
   type(c_ptr) :: conn, res
   character(:), allocatable :: conninfo, query
   
   conninfo = &quot;host=localhost user=postgres&quot;
   
   ! Connect
   conn = PQconnectdb(conninfo)
   
   ! Error handling for connection 
   if (PQstatus(conn) /= CONNECTION_OK) then
      print *, PQerrorMessage(conn)
      error stop
   end if

   ! Command to create a user account
   query = &quot;create role shinobu with createdb login password &#39;foobar&#39;;&quot;
   res = PQexec(conn, query)

   ! Error handling for command execution
   if (PQresultStatus(res) /= PGRES_COMMAND_OK ) then
      print *, PQresultErrorMessage(res)
      call PQfinish(conn)
      error stop
   end if

   call PQclear(res)

   ! Command to create database &#39;simulation&#39;
   query = &quot;create database simulation with owner shinobu;&quot;
   res = PQexec(conn, query)

   ! Error handling for command execution 
   if (PQresultStatus(res) /= PGRES_COMMAND_OK ) then
      print *, PQresultErrorMessage(res)
   end if

　　! Free the result object
   call PQclear(res)
   
   ! Free the connection object
   call PQfinish(conn)

end program create_database</code></pre>
         <p>Here, feel free to modify the server address, create a
         username and password, and choose the database name according
         to your environment. Throughout this article, for example, we
         assume the server host is <code>localhost</code>, the username
         is <code>shinobu</code>, the password is <code>foobar</code>,
         and the database name is <code>simulation</code>. Note that at
         the initial connection, it connects to the PostgreSQL server on
         localhost with the administrator account <code>postgres</code>.
         If necessary, you should add
         <code>password=</code><em>password-of-postgres</em> to the
         <code>conninfo</code> string.</p>
         <h3 id="create-table">Create Table</h3>
         <p>Next, we prepare a table to actually write simulation
         information.</p>
         <p>Here, you need to use the user, database, and password
         created in the previous section for the connection information
         written in <code>conninfo</code>.</p>
         <pre class="fortran"><code>program create_table
   use :: libpq
   use, intrinsic :: iso_c_binding
   implicit none
   
   type(c_ptr) :: conn, res
   character(:), allocatable :: conninfo, query
   integer :: i

   conninfo = &quot;host=localhost user=shinobu dbname=simulation password=foobar&quot;
   conn = PQconnectdb(conninfo)
   if (PQstatus(conn) /= 0) then
      print *, PQerrorMessage(conn)
      error stop
   end if

   query = &quot;create table advection &amp;
   &amp; (sim_id      decimal(4,0)      not null, &amp;
   &amp;  start_date  date              ,         &amp;
   &amp;  sim_name    varchar(100)      not null, &amp;
   &amp;  cs          double precision  not null, &amp;
   &amp;  dt          double precision  not null, &amp;
   &amp;  dx          double precision  not null, &amp; 
   &amp;  courant     double precision  ,         &amp;
   &amp;  length      double precision  ,         &amp;
   &amp;  nx          integer           not null, &amp;
   &amp;  nstep       integer           not null, &amp;   
   &amp;  dat_file    varchar(256)      not null, &amp;
   &amp;  primary key(sim_id));&quot;
   
   res = PQexec(conn, query)
   if (PQresultStatus(res) /= PGRES_COMMAND_OK) then
      print *, PQresultErrorMessage(res)
   end if 

   call PQclear(res)
   call PQfinish(conn)

end program create_table</code></pre>
         <p>As indicated by the beginning of the string variable
         <code>query</code> with ‘create table advection’, this query
         creates a table named <code>advection</code>. This subsequent
         continuation lines list multiple attributes of the table,
         including their names, types, and options. And the
         <code>primary key(sim_id)</code> on the final continuation line
         specifies an attribute with a constraint to uniquely identify
         records in this table.</p>
         <h4 id="check-the-table">Check the Table</h4>
         <p>After running this program, you can inspect the database and
         table information using the <code>psql</code> command, which is
         PostgreSQL’s command-line interface.</p>
         <p>Executing the command
         <code>psql -h localhost -U shinobu -d simulation</code> in the
         terminal and querying <code>select * from advection;</code> at
         the <code>simulation=&gt;</code> prompt, if you obtain a list
         of attribute names like the following, it indicates
         success.</p>
         <pre class="shell"><code>$ psql -h localhost -U shinobu -d simulation
psql (15.4)
Type &quot;help&quot; for help.

simulation=&gt; select * from advection;
 sim_id | start_date |   sim_name    | cs |   dt   |  dx   | courant | l | nx  | nstep |      dat_file
--------+------------+---------------+----+--------+-------+---------+---+-----+-------+--------------------</code></pre>
         <p>We will proceed to register data for this table.</p>
         <h2 id="execute-simulations">Execute Simulations</h2>
         <p>The program to be executed here consists of the following
         elements:</p>
         <ul>
         <li>Main Program: With experiments for two different schemes,
         it has 2 loops that run 32 experiment in total, varying
         parameters for each experiment.</li>
         <li>Internal procedures:
         <ul>
         <li><code>main_loop</code> subroutine: Takes parameters
         characterizing a simulation as arguments and executes single
         simulation.</li>
         <li><code>data_output</code> subroutine: Writes values of x in
         the first columun and u in the second column to output file,
         with two empty lines as separators between data sets to
         facilitate reading reading by Gnuplot.</li>
         <li><code>data_registration</code> subroutine: After the
         execution of <code>main_loop</code>, registers the experiment
         parameters and the path to the output file in the
         database.</li>
         </ul></li>
         </ul>
         <h3 id="main_loop"><code>main_loop</code></h3>
         <p>The time integration loop for numerical simulation is
         included in the <code>main_loop</code> subroutine. This
         subroutine takes parameters characterizing one experiment as
         arguments. When this subroutine is executed, the filename is
         stored in the argument <code>filename</code>, and the
         experiment result are written to a <code>.dat</code> file with
         this name.</p>
         <pre class="fortran"><code>subroutine main_loop(cs, dt, dx, nstep, filename, offset_k, k, prefix)
   implicit none
   real(real64), intent(in) :: cs, dt, dx
   integer(int32), intent(in) :: k
   character(:), allocatable, intent(inout) :: filename
   integer :: offset_k
   character(*), intent(in) :: prefix
   integer, intent(out) :: nstep

   character(4) :: code
   integer :: nth_out
   real(real64) :: tout, time
   real(real64) :: Courant

   integer :: i
   integer :: uni

   real(real64), allocatable :: x(:)
   real(real64), allocatable :: u(:), f(:), u_new(:), f0(:)

   write(code, &#39;(1i4.4)&#39;) k + (offset_k - 1)

   Courant = cs*dt/dx

   write(error_unit, &#39;(a, i0, a)&#39;) &quot;### START &quot;, k, &quot;-th Simulation ###&quot;
   write(error_unit, &#39;(a, f10.3)&#39;) &quot; Courant number: &quot;, Courant

   ! Initialize
   uni = 100
   nth_out = 0
   nstep = 1
   time = 0d0
   tout = 0
   allocate(x(0:nx), source=0d0)
   allocate(u(0:nx), source=0d0)
   allocate(u_new(0:nx), source=0d0)
   allocate(f0(0:nx), source=0d0)
   allocate(f(0:nx), source=0d0)
   
   ! set spacial grid
   x(0) = 0d0
   do i = 1, nx
      x(i) = x(0) + dx*dble(i)
   end do

   ! Initial condition
   do i = 0, nx
      if (x(i) &lt; 0.1d0) then
         u(i) = 1d0
      else
         u(i) = 0d0
      end if
   end do

   filename = &#39;result/&#39;//trim(adjustl(prefix))//code//&#39;.dat&#39;
   
   open(uni, file=filename, form=&#39;formatted&#39;, status=&#39;replace&#39;)
   call data_output(uni, x, u, tout, time, 0, nth_out)

   ! time integration loop
   do
      nstep = nstep + 1
      time = time + dt

      f0(:) = cs*u(:) ! numerical flux

      ! Lax-Friedrich scheme
      if (trim(prefix) == &#39;LF_&#39;) then
         do i = 1, nx-1
            f(i) = 0.5d0*(f0(i+1)+f0(i)) - 0.5d0*dx/dt *(u(i+1) - u(i))
         end do          
      end if

      ! Lax-Wendroff scheme
      if (trim(prefix) == &#39;LW_&#39;) then
         do i = 1, nx-1
            f(i) = 0.5d0*( (1d0-Courant)*f0(i+1) + (1d0+Courant)*f0(i) )
         end do
      end if

      ! Explicit Eular method
      do i = 1, nx-1 
         u_new(i) = u(i) - Courant*(f(i) - f(i-1))
      end do

      ! Update u
      u(2:nx-1) = u_new(2:nx-1)

      ! Boundary Condition
      u(1) = u(2)
      u(nx) = u(nx-1)

      if (time &gt;= tout) call data_output(uni, x, u, tout, time, nstep, nth_out)
      if (time &gt;  tend) exit

   end do

   close(uni)
   write(error_unit, fmtStop) nstep, time
   write(error_unit, &#39;(a)&#39;) &quot;### Normal STOP ###&quot;
end subroutine main_loop</code></pre>
         <p>Within the included do-loop, the calculation of the
         numerical flux for the two schemes, as illustrated in the
         previous section’s mathematical expressions, is performed by
         switching based on the value of the argument
         <code>prefix</code>.</p>
         <h3 id="data_output"><code>data_output</code></h3>
         <p>The subroutine for writing data is as follows:</p>
         <pre class="fortran"><code>subroutine data_output (uni, x, u, tout, time, nstep, nth_out)
   implicit none
   integer, intent(in) :: uni
   real(real64), intent(in) :: x(:), u(:)
   real(real64), intent(inout) :: tout
   real(real64), intent(in) :: time
   integer, intent(in) :: nstep
   integer, intent(inout) :: nth_out 
   integer :: i

   do i = 1, nx
      write(uni, fmtOut) x(i), u(i)
   end do
   
   ! Write two empty lines (for separating datasets for Gnuplot) into the file.
   write(uni, &#39;(/)&#39;)  

   tout = tout + tout_interval
   
   write(error_unit, fmtErrOut) nstep, time, nth_out
   nth_out = nth_out + 1
end subroutine data_output</code></pre>
         <h3 id="data_registration"><code>data_registration</code></h3>
         <p>The subroutine for registering data in the database is as
         follows:</p>
         <pre class="fortran"><code>subroutine data_registration(conn, simu_name, filename, offset_k, k, cs, dt, dx, nstep, date)
   use :: iso_c_binding
   use :: libpq
   implicit none
   type(c_ptr), intent(in) :: conn
   character(*), intent(in) :: simu_name
   character(*), intent(in) :: filename
   integer, intent(in) :: k, offset_k
   real(real64), intent(in) :: cs, dt, dx
   integer, intent(in) :: nstep
   character(*), intent(in) :: date

   character(:), allocatable :: query
   character(256) :: values(11)

   type(c_ptr) :: res
   real(real64) :: Courant
   character(4) :: code
   integer :: i

   Courant = cs*dt/dx

   ! Write the values into array 
   write(code, &#39;(1i4.4)&#39;) k + (offset_k-1)
   values(1) = code
   values(2) = trim(adjustl(date))
   values(3) = trim(simu_name)
   write(values(4),  &#39;(f16.8)&#39;) cs
   write(values(5),  &#39;(f16.8)&#39;) dt
   write(values(6),  &#39;(f16.8)&#39;) dx
   write(values(7),  &#39;(f16.8)&#39;) Courant
   write(values(8),  &#39;(f16.8)&#39;) L 
   write(values(9),  &#39;(i0)&#39;) nx
   write(values(10), &#39;(i0)&#39;) nstep
   values(11) = trim(adjustl(filename)) 

   do i = 1, size(values)
      values(i) = trim(adjustl(values(i)))
   end do

   query = &#39;insert into advection &amp;
   &amp;        (sim_id, start_date, sim_name, cs, dt, dx, courant, l, nx, nstep, dat_file) &amp;
   &amp; values ($1,     $2,         $3,       $4, $5, $6, $7,     $8, $9, $10,   $11)&#39;

   res = PQexecParams(conn, query, size(values), [(0, i=1,size(values))], values(:))

   if (PQresultStatus(res) /= PGRES_COMMAND_OK) then
      print *, PQresultErrorMessage(res)
   end if

   call PQclear(res)

end subroutine data_registration</code></pre>
         <p>This includes a query called the <code>insert</code>
         statement, which inserts a record into the table in the
         database.</p>
         <p>This insert statement is executed using the
         <code>PQexecParams</code> function, which allows you to include
         placeholders in the command string and pass their values
         separately as an array of strings. For detailed information
         about the arguments of this function, please refer to the <a
         href="https://shinobuamasaki.github.io/libpq-fortran/interface/pqexecparams.html">PQexecParams
         page in the Libpq-Fortran documentation.</a></p>
         <h3 id="execute-main-program">Execute Main Program</h3>
         <p>All necessary ingredients are now in place. Write the main
         program and execute the simulations. <a
         href="https://github.com/ShinobuAmasaki/ShinobuAmasaki.github.io/blob/main/sample-codes/sim-with-db/main.f90">The
         entire code of main program can be obtained from this link on
         GitHub.</a></p>
         <pre class="fortran"><code>program main
   use, intrinsic :: iso_fortran_env
   use, intrinsic :: iso_c_binding
   use :: libpq

   implicit none

   real(real64), parameter :: tend = 0.6d0
   real(real64), parameter :: tout_interval = 0.1d0

   integer, parameter :: NX = 200     ! The number of spatial grid divisions 
   real(real64), parameter :: L = 1d0 ! The length of computing region 

   character(*), parameter  :: fmtOut   = &#39;(e10.3, 1x, e10.3, 1x, i0)&#39;
   character(*), parameter  :: fmtErrOut= &quot;(&#39;  output  &#39;, &#39;step=&#39;, i8, &#39; time=&#39;, e10.3, &#39; nth_out =&#39;, i3)&quot;
   character(*), parameter  :: fmtStop  = &quot;(&#39;  stop    &#39;, &#39;step=&#39;, i8, &#39; time=&#39;, e10.3)&quot;
   
   character(:), allocatable :: filename
   integer :: k

   real(real64) :: cs, dt, dx
   integer :: nstep, offset_k

   type(c_ptr) :: conn
   character(:), allocatable :: conninfo
   character(10) :: date = &#39;2023-12-10&#39;
   
   ! Connection
   conninfo = &#39;host=localhost dbname=simulation user=shinobu&#39;
   conn = PQconnectdb(conninfo)

   if (PQstatus(conn) /= 0) then
      print *, PQerrorMessage(conn)
      error stop 
   end if

   ! Execute 16 simulations on Lax-Friedrich scheme (id = 1:16).
   offset_k = 1
   do k = 1, 16
      cs = 1d0
      dt = 5d-4  + 3d-4*dble(k-1)
      dx = L/dble(nx)
      call main_loop(cs, dt, dx, nstep, filename, offset_k, k, &#39;LF_&#39;)
      call data_registration(conn, &#39;Lax-Friedrich&#39;, filename, offset_k, k, cs, dt, dx, nstep, date)
   end do
   
   ! Execute 16 simulations on Lax-Wendroff scheme (id=17:32)
   offset_k = 17
   do k = 1, 16
   	cs = 1d0
   	dt = 5d-4  + 3d-4*dble(k-1)
   	dx = L/dble(nx)
   	call main_loop(cs, dt, dx, nstep, filename, offset_k, k, &#39;LW_&#39;)
      call data_registration(conn, &#39;Lax-Wendroff&#39;, filename, offset_k, k, cs, dt, dx, nstep, date)
   end do
   
contains

　! This includes the three subroutines mentioned above.
　! ...
　
end program main</code></pre>
         <h3 id="check-the-registered-data">Check the Registered
         Data</h3>
         <p>Execute
         <code>psql -h localhost -U shinobu -d simulation</code> in the
         terminal to launch psql, then run
         <code>select * from advection;</code> to confirm that 32
         records have been inserted.</p>
         <p>With this, we have successfully registered the result of
         numerical simulations into the database server. In the next
         section, we will demonstrate how to retrieve the registered
         data and draw plots from Fortran.</p>
         <h2 id="retrieve-the-data-for-plot">Retrieve the Data for
         Plot</h2>
         <p>Here, we will describe the process of retrieving data
         managed in PostgreSQL using Libpq-Fortran, passing the values
         from Fortran to a Gnuplot script, and drawing plots.</p>
         <p>It is noting that if you wish to specify the drawing process
         in detail using Fortran, you may need to utilize libraries such
         as PLPlot.</p>
         <p>The procedure here is as folllows:</p>
         <ol type="1">
         <li>Extract some records from the <code>advection</code> table
         in the <code>simulation</code> database.</li>
         <li>Output the file paths of these data files.</li>
         <li>Concatenate them into a string variable separated by spaces
         and pass it as command-line arguments to the script.</li>
         </ol>
         <p>The following code is a sample program for
         <code>plot.f90</code>:</p>
         <pre class="fortran"><code>program plot
   use :: libpq
   use, intrinsic :: iso_c_binding
   implicit none
   
   character(:), allocatable :: conninfo, query, cmd
   type(c_ptr) :: conn, res
   integer :: i

   ! Connection
   conninfo = &quot;host=localhost dbname=simulation user=shinobu&quot;
   conn = PQconnectdb(conninfo)
   if (PQstatus(conn) /= 0) then
      print *, PQerrorMessage(conn)
      error stop
   end if

	cmd = &quot;gnuplot -c plot.gp &quot;

   query = &quot;select dat_file from advection where sim_name = &#39;Lax-Wendroff&#39; and courant &gt; 0.55;&quot;
   
   ! Execute the query
   res = PQexec(conn, query)

   ! Error Handling
   if (PQresultStatus(res) /= PGRES_COMMAND_OK) then
      print *, PQresultErrorMessage(res)
      call PQfinish(conn)
      error stop
   end if 

   ! Concatenate
   do i = 0, PQntuples(res) - 1
      cmd = cmd // &#39; &#39;// PQgetvalue(res, i, 0)
   end do

   ! Execute the command
	print *, cmd
   call system(cmd)

   call PQclear(res)
   call PQfinish(conn)
   
end program plot</code></pre>
         <p>In this program, the query
         <code>"select dat_file from advection where sim_name = 'Lax-Wendroff' and courant &gt; 0.55;"</code>
         instructs to extract and output file paths for all records
         where the simulation name is ‘Lax-Wendroff’ and the Courant
         number is greater than 0.55.</p>
         <p>The results of this query are extracted from the object
         indicated by the <code>c_ptr</code> type variable
         <code>res</code> using functions provided by libpq. In the
         concatenation’s <code>do</code> loop, a loop is instructed to
         run for <code>PQntuples(res) -1</code> iterations, starting
         from 0. Within this loop, the function
         <code>PQgetvalue(res, i, 0)</code> is called to retrieve the
         data from the i-th row and 0th column, and it is concatenated
         into the variable <code>cmd</code>.</p>
         <p>The actual command to be executed would be as the
         following:</p>
         <pre class="shell"><code>gnuplot -c plot.gp  result/LW_0024.dat result/LW_0025.dat result/LW_0026.dat result/LW_0027.dat result/LW_0028.dat result/LW_0029.dat result/LW_0030.dat result/LW_0031.dat result/LW_0032.dat</code></pre>
         <p>Here, <code>plot.gp</code> would be a Gnuplot script like
         the following:</p>
         <pre><code>set term pngcairo size 1600,1200
set termoption noenhanced
set output &quot;plot9.png&quot;

set xlabel &quot;x&quot;
set ylabel &quot;u&quot;
set xrange [0:1]
set yrange [-0.5:2.0]

set multiplot layout 3,3

do for [i=1:9] {
   path = ARGV[i]
   set title path

   unset xlabel
   unset ylabel
   if ( i % 3 == 1) {
      set ylabel &quot;u&quot;
   }
   if ( i &gt; 6 ) {
      set xlabel &quot;x&quot;
   }

   plot  path index 0 using 1:2 with lines title &#39;t = 0.0&#39;, \
      path index 1 using 1:2 with lines title &#39;t = 0.1&#39;, \
      path index 2 using 1:2 with lines title &#39;t = 0.2&#39;, \
      path index 3 using 1:2 with lines title &#39;t = 0.3&#39;, \
      path index 4 using 1:2 with lines title &#39;t = 0.4&#39;, \
      path index 5 using 1:2 with lines title &#39;t = 0.5&#39;, \
      path index 6 using 1:2 with lines title &#39;t = 0.6
}

unset multiplot</code></pre>
         <p>Please use the latest version of Gnuplot to execute this
         script.</p>
         <p>Executing this program (<code>plot.f90</code>) allows you to
         generate an image like the following:</p>
         <div class="large-img">
         <figure>
         <img src="../img/sim-with-db-plot-9.png"
         alt="A Image includes 9 results" />
         <figcaption aria-hidden="true">A Image includes 9
         results</figcaption>
         </figure>
         </div>
         <p>In conclusion, we have successfully loaded data from a
         PostgreSQL server using Libpq-Fortran and drawn a plot with a
         Gnuplot script.</p>
         <h2 id="conclusion">Conclusion</h2>
         <p>I have described the process of registering numerical
         simulation data in PostgreSQL using the Libpq-Fortran library
         and retrieving that data from the server for further use.</p>
         <p>This approach is obviously useful in scenarios where the
         same program needs to be executed massively with varying
         parameters. There have been instances when I chose to leverage
         a database for parameter exploration, particularly when
         conducting an exhaustive search of parameters to evaluate the
         stability of a finite difference scheme. As seen throughout
         this process, it’s now possible to directly register data from
         Fortran, whereas at that time, the data registration was done
         from another language.</p>
         <p>In the example we covered this time, it was relatively easy
         to manage because one simulation corresponded to one record.
         However, if we consider cases where multiple files are output
         for a single simulation, the complexity of data management
         increases. I hope to write about this aspect at some point in
         the future.</p>
      </div>
   </div>
</main>
<script>
   renderMathInElement(
     document.body,
     {
       delimiters: [
         {left: "$", right: "$", display: true},
         {left: "\\[", right: "\\]", display: true},
         {left: "\\(", right: "\\)", display: false}
       ],
       ignoredTags: [
         "script",
         "noscript",
         "style",
         "textarea",
         "pre",
         "code"
       ]
     }
   );
 </script>
</body>
</html>
